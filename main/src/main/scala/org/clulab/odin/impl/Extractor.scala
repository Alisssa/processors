package org.clulab.odin.impl

import org.clulab.processors.Document
import org.clulab.odin._


trait Extractor {
  def name: String
  def labels: Seq[String]
  def label: String = labels.head  // the first label in the sequence is the default
  def priority: Priority
  def keep: Boolean  // should we keep mentions generated by this extractor?
  def action: Action

  def findAllIn(sent: Int, doc: Document, state: State): Seq[Mention]

  def findAllIn(doc: Document, state: State): Seq[Mention] = for {
    i <- 0 until doc.sentences.size
    m <- findAllIn(i, doc, state)
  } yield m
}

class TokenExtractor(
    val name: String,
    val labels: Seq[String],
    val priority: Priority,
    val keep: Boolean,
    val action: Action,
    val pattern: TokenPattern
) extends Extractor {

  def findAllIn(sent: Int, doc: Document, state: State): Seq[Mention] = {
    val results = pattern.findAllIn(sent, doc, state)
    val mentions = for (r <- results) yield mkMention(r, sent, doc)
    action(mentions, state)
  }

  def mkMention(r: TokenPattern.Result, sent: Int, doc: Document): Mention =
    r.groups.keys find (_ equalsIgnoreCase "trigger") match {
      case Some(triggerKey) =>
        // having several triggers in the same rule is not supported
        // the first will be used and the rest ignored
        val int = r.groups(triggerKey).head
        val trigger = new TextBoundMention(labels, int, sent, doc, keep, name)
        val groups = r.groups - triggerKey transform { (argName, intervals) =>
          intervals.map(i => new TextBoundMention(labels, i, sent, doc, keep, name))
        }
        val args = mergeArgs(groups, r.mentions)
        new EventMention(labels, r.interval, trigger, args, Map.empty, sent, doc, keep, name)
      case None if r.groups.nonEmpty || r.mentions.nonEmpty =>
        // result has arguments and no trigger, create a RelationMention
        val groups = r.groups transform { (argName, intervals) =>
          intervals.map(i => new TextBoundMention(labels, i, sent, doc, keep, name))
        }
        val args = mergeArgs(groups, r.mentions)
        new RelationMention(labels, r.interval, args, Map.empty, sent, doc, keep, name)
      case None =>
        // result has no arguments, create a TextBoundMention
        new TextBoundMention(labels, r.interval, sent, doc, keep, name)
    }

  type Args = Map[String, Seq[Mention]]
  def mergeArgs(m1: Args, m2: Args): Args = {
    val merged = for (name <- m1.keys ++ m2.keys) yield {
      val args = m1.getOrElse(name, Vector.empty) ++ m2.getOrElse(name, Vector.empty)
      name -> args.distinct
    }
    merged.toMap
  }
}

class DependencyExtractor(
    val name: String,
    val labels: Seq[String],
    val priority: Priority,
    val keep: Boolean,
    val action: Action,
    val pattern: DependencyPattern
) extends Extractor {

  def findAllIn(sent: Int, doc: Document, state: State): Seq[Mention] = {
    val mentions = pattern.getMentions(sent, doc, state, labels, keep, name)
    action(mentions, state)
  }
}


class MultiSentenceExtractor(
  val name: String,
  val labels: Seq[String],
  val priority: Priority,
  val keep: Boolean,
  val action: Action,
  // the maximum number of sentences to look behind for pattern2
  val leftWindow: Int,
  // the maximum number of sentences to look ahead for pattern2
  val rightWindow: Int,
  val anchorPattern: TokenExtractor,
  val neighborPattern: TokenExtractor,
  val anchorRole: String,
  val neighborRole: String
) extends Extractor {

  def findAllIn(sent: Int, doc: Document, state: State): Seq[Mention] = {
    anchorPattern.findAllIn(sent, doc, state) match {
      // the rule failed
      case Nil => Nil
      // the anchor matched something
      case pattern1Mentions =>

        val leftWindowMatches = leftWindow match {
          // -1 means don't attempt to match anything to the left
          case -1 => Nil
          case lw if lw >= 0 =>
            for {
              i <- sent - leftWindow until sent
              // is the sentence within the allotted window?
              if 0 <= i && i < doc.sentences.length
              // attempt to match pattern2
              pattern2Mentions = neighborPattern.findAllIn(i, doc, state)
              anchor <- pattern1Mentions
              neighbor <- pattern2Mentions
              // for left window, neighbor must precede anchor
              if neighbor precedes anchor
            } yield mkMention(anchor, neighbor)
          case _ => throw OdinCompileException(""""left-window" value for '$name' must be >= -1""")
        }

        val rightWindowMatches = rightWindow match {
          // -1 means don't attempt to match anything to the right
          case -1 => Nil
          case rw if rw >= 0 =>
            for {
              i <- sent until sent + rightWindow
              // is the sentence within the allotted window?
              if 0 <= i && i < doc.sentences.length
              // attempt to match pattern2
              pattern2Mentions = neighborPattern.findAllIn(i, doc, state)
              anchor <- pattern1Mentions
              neighbor <- pattern2Mentions
              // for right window, anchor must precede neighbor
              if anchor precedes neighbor
            } yield mkMention(anchor, neighbor)
          case _ => throw OdinCompileException(""""right-window" value for '$name' must be >= -1""")
        }

        action(leftWindowMatches ++ rightWindowMatches , state)
    }
  }

  def mkMention(anchor: Mention, neighbor: Mention): Mention = {
    val args = Map(anchorRole -> Seq(anchor), neighborRole -> Seq(neighbor))
    // FIXME: we should redo Mention's interval (and sentence)
    new RelationMention(labels, anchor.tokenInterval, args, Map.empty, anchor.sentence, anchor.document, keep, name)
  }
}
